<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Calm systems keep promises visible, failure paths graceful, and teams in the loop.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles.css">
  <title>Designing calm systems · Andrew Wu</title>
</head>
<body class="post-page">
  <a class="skip-link" href="#content">Skip to content</a>

  <main class="post-shell">
    <header class="post-header">
      <div class="post-links">
        <a class="inline-link" href="./posts-archive.html">Blog archive</a>
        <span aria-hidden="true">·</span>
        <a class="inline-link" href="../index.html">Portfolio home</a>
      </div>
      <p class="eyebrow">Blog · Post</p>
      <p class="post-meta">Dec 1, 2025 · 4 min read</p>
      <h1>Designing calm systems</h1>
    </header>

    <article id="content" class="post-body">
<p>The most reliable products I have worked on share a trait: they feel calm. Calm systems make intent obvious, degrade predictably when things wobble, and help humans recover fast. Achieving that calmness requires thinking beyond uptime and shipping small habits into the codebase and the team.</p>
<h2>Frame the promises first</h2>
<p>Before drawing diagrams, write down the promises your system must keep: latency windows, data freshness, failure domains, and who owns each promise. This keeps scope honest and informs where you invest observability. A short “promises” doc becomes the anchor for design reviews and incident postmortems.</p>
<h2>Design for graceful failure paths</h2>
<p>The difference between a nuisance and an outage is usually how gracefully the system handles the non-happy path. Rate limiting that is coordinated, queues sized to buy time, and idempotent work queues keep partial failures from compounding. When a dependency slows, users should feel a brief slowdown, not a blank page.</p>
<h2>Make the feedback loop tight</h2>
<p>Calmness shows up when teams can see and fix issues quickly. Emit signals that line up with the promises: SLI-aligned alerts, traces that show retries, and dashboards that call out saturation early. Pair those with runbooks that include “good defaults” so on-call engineers spend less time guessing and more time deciding.</p>
<h2>Ship smaller, steadier changes</h2>
<p>The fastest way to lose calm is a risky deploy. Break features into toggles, stage releases, and rehearse rollbacks. Keeping changesets small lowers cognitive load and creates space to observe the system after each step, which in turn builds trust and velocity.</p>
<p>Calm systems are rarely flashy, but they become the backbone for ambitious product bets. Start with promises, respect failure paths, tighten feedback loops, and your team will spend more time building and less time firefighting.</p>
    </article>
  </main>
</body>
</html>